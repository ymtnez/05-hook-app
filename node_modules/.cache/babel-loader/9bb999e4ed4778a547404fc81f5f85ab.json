{"ast":null,"code":"const apiKey = '83i7O10QCBh6UcA8OfZ2Bn9UJPR4f356';\n/**\r\n * El fetch es una promesa y como tal se maneja de la misma manera, por lo\r\n * que tiene un then, finally y catch. A ella retorna siempre algo.\r\n */\n\nconst peticion = fetch(`https://ap.giphy.com/v1/gifs/random?api_key=${apiKey}`);\n/**\r\n * En este caso peticion es una promesa y puedo accedr a los metodos then, finally\r\n * y catch. El resultado de fetch lo guardo en respuesta.\r\n * A su vez el metodo json es en si una promesa\r\n * \r\n    peticion.then( (resp) => {\r\n        resp.json().then( (datos_json) => {\r\n            //Aqui desestructuro el objeto data e images para llegar al objeto original\r\n            const {data:{images:{original}}} = datos_json;\r\n            const url = original.url;            \r\n            \r\n            * Primero creo el elemento imagen que en html es una img, luego al atributo\r\n            * src (source) de img le asigno el valor de la constante url (la extraje de\r\n            * la desestructuracion del objeto data {data:{images:{original}}}), finalmente\r\n            * ubicamos imagen (de tipo img en HTML) en el body\r\n            *\r\n        const imagen = document.createElement('img');\r\n        imagen.src = url;\r\n        \r\n        document.body.append(imagen);\r\n        })\r\n    });\r\n*/\n\n/**\r\n * En el codigo anterior tenemos: resp.json().then( (datos_json) => { ... esto se conoce\r\n * como promesas encadenadas (es decir promesas que a su vez devuelven una promesa)\r\n */\n\npeticion.then(resp => resp.json()) //En este caso hacemos un return implicito\n.then(_ref => {\n  let {\n    data\n  } = _ref;\n  const {\n    url\n  } = data.images.original;\n  const imagen = document.createElement('img');\n  imagen.src = url;\n  document.body.append(imagen);\n}).catch(err => console.warn('UPss!!!', err));","map":{"version":3,"names":["apiKey","peticion","fetch","then","resp","json","data","url","images","original","imagen","document","createElement","src","body","append","catch","err","console","warn"],"sources":["/media/ymtnez/AdminFile/Personal/Desarrollo/Ejemplos/react/02-intro-javascript/src/index.js"],"sourcesContent":["const apiKey = '83i7O10QCBh6UcA8OfZ2Bn9UJPR4f356';\r\n\r\n/**\r\n * El fetch es una promesa y como tal se maneja de la misma manera, por lo\r\n * que tiene un then, finally y catch. A ella retorna siempre algo.\r\n */\r\nconst peticion = fetch(`https://ap.giphy.com/v1/gifs/random?api_key=${apiKey}`);\r\n\r\n/**\r\n * En este caso peticion es una promesa y puedo accedr a los metodos then, finally\r\n * y catch. El resultado de fetch lo guardo en respuesta.\r\n * A su vez el metodo json es en si una promesa\r\n * \r\n    peticion.then( (resp) => {\r\n        resp.json().then( (datos_json) => {\r\n            //Aqui desestructuro el objeto data e images para llegar al objeto original\r\n            const {data:{images:{original}}} = datos_json;\r\n            const url = original.url;            \r\n            \r\n            * Primero creo el elemento imagen que en html es una img, luego al atributo\r\n            * src (source) de img le asigno el valor de la constante url (la extraje de\r\n            * la desestructuracion del objeto data {data:{images:{original}}}), finalmente\r\n            * ubicamos imagen (de tipo img en HTML) en el body\r\n            *\r\n        const imagen = document.createElement('img');\r\n        imagen.src = url;\r\n        \r\n        document.body.append(imagen);\r\n        })\r\n    });\r\n*/\r\n/**\r\n * En el codigo anterior tenemos: resp.json().then( (datos_json) => { ... esto se conoce\r\n * como promesas encadenadas (es decir promesas que a su vez devuelven una promesa)\r\n */\r\npeticion\r\n    .then( (resp) => resp.json())//En este caso hacemos un return implicito\r\n    .then( ({data}) => {\r\n        const {url} = data.images.original;\r\n\r\n        const imagen = document.createElement('img');\r\n        imagen.src   = url;\r\n        document.body.append(imagen);        \r\n    })\r\n    .catch(err => console.warn('UPss!!!', err));\r\n"],"mappings":"AAAA,MAAMA,MAAM,GAAG,kCAAf;AAEA;AACA;AACA;AACA;;AACA,MAAMC,QAAQ,GAAGC,KAAK,CAAE,+CAA8CF,MAAO,EAAvD,CAAtB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AACAC,QAAQ,CACHE,IADL,CACYC,IAAD,IAAUA,IAAI,CAACC,IAAL,EADrB,EACiC;AADjC,CAEKF,IAFL,CAEW,QAAY;EAAA,IAAX;IAACG;EAAD,CAAW;EACf,MAAM;IAACC;EAAD,IAAQD,IAAI,CAACE,MAAL,CAAYC,QAA1B;EAEA,MAAMC,MAAM,GAAGC,QAAQ,CAACC,aAAT,CAAuB,KAAvB,CAAf;EACAF,MAAM,CAACG,GAAP,GAAeN,GAAf;EACAI,QAAQ,CAACG,IAAT,CAAcC,MAAd,CAAqBL,MAArB;AACH,CARL,EASKM,KATL,CASWC,GAAG,IAAIC,OAAO,CAACC,IAAR,CAAa,SAAb,EAAwBF,GAAxB,CATlB"},"metadata":{},"sourceType":"module"}